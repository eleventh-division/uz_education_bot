// Generated by CoffeeScript 1.3.3
(function() {
  var Drip, HgChangeset, HgRepository, Queue, childProcess, hgOptions;

  childProcess = require('child_process');

  Drip = require('drip');

  HgChangeset = require('./changeset');

  Queue = require('./queue');

  hgOptions = ['--config', 'ui.interactive=True', 'serve', '--cmdserver', 'pipe'];

  HgRepository = (function() {
    /*
      Handles connection to the mercurial command server.
    
      ##\# Events
      ##\## error
      Fired when command server exited unexpectedly.
    */

    function HgRepository(path) {
      var _this = this;
      Drip.call(this, {
        delimeter: '::'
      });
      this.encoding = 'utf8';
      this.capabilities = [];
      this.isReadingBody = false;
      this.channel = '-';
      this.bodyLength = 0;
      this.buffer = new Buffer(0);
      this.queue = new Queue;
      this.cmd = {
        cmd: 'hello',
        o: [],
        buffer: '',
        parser: function(cmd) {
          var line, _i, _len, _ref, _results;
          _ref = cmd.o;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            line = _ref[_i];
            switch (line.tag) {
              case 'encoding':
                _results.push(_this.encoding = line.value);
                break;
              case 'capabilities':
                _results.push(_this.capabilities = line.value);
                break;
              default:
                _results.push(void 0);
            }
          }
          return _results;
        }
      };
      this.process = childProcess.spawn('hg', hgOptions, {
        cwd: path
      });
      this.process.stdout.on('data', function(data) {
        _this.buffer = Buffer.concat([_this.buffer, data]);
        return _this._parseBuffer();
      });
      this.process.stderr.on('data', function(data) {
        return console.log(data.toString('utf-8'));
      });
      this.process.on('exit', function(code) {
        var err, fn, isError, _ref;
        err = new Error("Server exited with code " + code);
        if (typeof ((_ref = _this.cmd) != null ? _ref.errorHandler : void 0) === 'function') {
          _this.cmd.errorHandler(err);
        }
        isError = (_this.cmd != null) || _this.queue.length > 0;
        while (_this.queue.length > 0) {
          fn = _this.queue.take().errorHandler;
          if (typeof fn === 'function') {
            fn(err);
          }
        }
        _this.cmd = null;
        if (isError) {
          return _this.emit('error', err);
        }
      });
    }

    HgRepository.prototype.close = function() {
      /*
          Closes connection to the mercurial command server.
      */
      return this.process.stdin.destroy();
    };

    HgRepository.prototype._parseBuffer = function() {
      var body, line, lines, p;
      while (true) {
        if (!this.isReadingBody) {
          if (this.buffer.length < 5) {
            return;
          }
          this.channel = String.fromCharCode(this.buffer.readUInt8(0));
          this.bodyLength = this.buffer.readUInt32BE(1);
          this.buffer = this.buffer.slice(5);
          this.isReadingBody = this.bodyLength > 0;
        }
        if (this.isReadingBody) {
          if (this.buffer.length < this.bodyLength) {
            return;
          }
          body = this.buffer.slice(0, this.bodyLength);
          this.buffer = this.buffer.slice(this.bodyLength);
          this.isReadingBody = false;
          if (this.channel === 'r') {
            body = this.cmd.code = body.readUInt32BE(0);
          } else {
            body = body.toString(this.encoding);
          }
          if (this.channel === 'r' || this.cmd.cmd === 'hello') {
            if (this.cmd.buffer.length > 0) {
              this.cmd.o.push(this.cmd.buffer);
            }
            this.cmd.parser(this.cmd);
            this.cmd = null;
            this._processQueue();
            return;
          }
          this.cmd.buffer += body;
          lines = this.cmd.buffer.split('\n');
          this.cmd.buffer = lines.pop();
          lines = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = lines.length; _i < _len; _i++) {
              line = lines[_i];
              if (line.charAt(0) === ' ') {
                _results.push(line.substr(1));
              } else {
                p = line.indexOf(':');
                if (p === -1) {
                  _results.push(line);
                } else {
                  _results.push({
                    tag: line.substr(0, p),
                    value: line.substr(p + 1).replace(/^\s+/, '')
                  });
                }
              }
            }
            return _results;
          })();
          this.cmd.o = this.cmd.o.concat(lines);
        }
      }
    };

    HgRepository.prototype._processQueue = function() {
      var buffer, cmd, _ref;
      if ((this.cmd != null) || this.queue.length === 0) {
        return;
      }
      cmd = this.cmd = this.queue.take();
      if ((_ref = cmd.opts) == null) {
        cmd.opts = {};
      }
      cmd.buffer = '';
      cmd.o = [];
      buffer = new Buffer(15 + cmd.cmd.length);
      buffer.write("runcommand\n", 0, 11, 'ascii');
      buffer.writeUInt32BE(cmd.cmd.length, 11);
      buffer.write(cmd.cmd, 15, 'ascii');
      return this.process.stdin.write(buffer);
    };

    HgRepository.prototype.summary = function(fn) {
      /*
          Returns summary for the working directory.
      */

      var parser;
      parser = function(cmd) {
        console.log(cmd.o);
        return fn(null, cmd.o);
      };
      this.queue.add({
        cmd: 'summary',
        parser: parser
      });
      return this._processQueue();
    };

    HgRepository.prototype.log = function(fn) {
      /*
          Returns array of HgChangeset.
      */

      var parser;
      parser = function(cmd) {
        var changeset, line, log, _i, _len, _ref;
        log = [];
        _ref = cmd.o;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          if (typeof line === 'string') {
            log.push(changeset);
          } else {
            switch (line.tag) {
              case 'changeset':
                changeset = new HgChangeset(line.value);
                break;
              case 'tag':
                changeset.tag = line.value;
                break;
              case 'branch':
                changeset.branch = line.value;
                break;
              case 'parent':
                changeset.parents.push(new HgChangeset(line.value));
                break;
              case 'user':
                changeset.user = line.value;
                break;
              case 'date':
                changeset.date = new Date(line.value);
                break;
              case 'summary':
                changeset.summary = line.value;
            }
          }
        }
        return fn(null, log);
      };
      this.queue.add({
        cmd: 'log',
        parser: parser,
        errorHandler: fn
      });
      return this._processQueue();
    };

    return HgRepository;

  })();

  module.exports = HgRepository;

}).call(this);
